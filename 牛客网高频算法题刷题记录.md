牛客网高频算法题刷题记录

链表

```c++
//1.翻转链表
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        ListNode*pre=nullptr;
        ListNode *next=nullptr;
        while(pHead!=nullptr){
            next=pHead->next;
            pHead->next=pre;
            pre=pHead;
            pHead=next;
        }
        return pre;
    }
};
//2.合并两个排序链表
 ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        if(!pHead1)return pHead2;
        else if(!pHead2)return pHead1;
        ListNode *pHead=nullptr;
        if(pHead1->val<pHead2->val){
            pHead=pHead1;
            pHead->next=Merge(pHead1->next, pHead2);
        }
        else{
            pHead=pHead2;
            pHead->next=Merge(pHead1, pHead2->next);
        }
        return pHead;
    }
//3.链表中环的入口节点
class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead) {
        ListNode*slow=pHead;
        ListNode*fast=pHead;
        while(fast!=nullptr&&fast->next!=nullptr){
            slow=slow->next;
            fast=fast->next->next;
            if(slow==fast){
                ListNode*index1=fast;
                ListNode*index2=pHead;
                while(index1!=index2){
                    index1=index1->next;
                    index2=index2->next;
                }
                return index2;
            }
        }
        return nullptr;
    }
};
//4.删除链表中的倒数第n个节点
ListNode* removeNthFromEnd(ListNode* head, int n) {
       //双指针法实现
        ListNode*dummy=new ListNode(-1);
        dummy->next=head;
        ListNode*fast=dummy;
        ListNode*slow=dummy;
        while(n--&&fast->next!=nullptr){
            fast=fast->next;
        }
        fast=fast->next;
        while(fast!=nullptr){
            slow=slow->next;
            fast=fast->next;
        }
        slow->next=slow->next->next;
        return dummy->next;
    }
//5.两个链表的第一个公共节点
ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        //法1：有手就行的哈希表法
        //法2：双指针法
        ListNode*p1=pHead1;
        ListNode*p2=pHead2;
        if(pHead1==nullptr||pHead2==nullptr)return nullptr;
        while(p1!=p2){
            p1=p1!=nullptr?p1->next:pHead2;
            p2=p2!=nullptr?p2->next:pHead1;
        }
        return p1;
    }
//6.判断是否为回文链表
 	bool isHuiwen(vector<int>&num){
        for(int i=0,j=num.size()-1;i<j;i++,j--){
            if(num[i]!=num[j])return false;
        }
        return true;
    }
    bool isPail(ListNode* head) {
        vector<int>vec;
        ListNode*cur=head;
        while(cur!=nullptr){
            vec.push_back(cur->val);
            cur=cur->next;
        }
        return isHuiwen(vec);
    }
//7.单链表的排序
ListNode* sortInList(ListNode* head) {
        // write code here
        //基本思路，用vector辅助
        //1.构建vector辅助数组
        vector<int>vec;
        ListNode* cur=head;
        while(cur!=nullptr){
            vec.push_back(cur->val);
            cur=cur->next;
        }
        //2.排序
        sort(vec.begin(),vec.end());
        //3.重建排序链表
        ListNode *dummy=new ListNode(0);
        ListNode *res=new ListNode(0);
        dummy->next=res;
        for(int i:vec){
            res->next=new ListNode(i);
            res=res->next;
        }
        res->next=nullptr;
        return dummy->next->next;
    }
```

2.二叉树

```c++
//1.求二叉树的最大深度
int maxDepth(TreeNode* root) {
        if(root==nullptr)return 0;
        int left=maxDepth(root->left);
        int right=maxDepth(root->right);
        return left>right?1+left:1+right;
    }
//2.二叉树的前序遍历
vector<int> preorderTraversal(TreeNode* root) {
        // write code here
        //迭代法实现
        vector<int>res;
        stack<TreeNode*>st;
        if(root!=nullptr)st.push(root);
        while(!st.empty()){
            TreeNode*node=st.top();
            st.pop();
            res.push_back(node->val);
            //前序遍历顺序根左右，入栈顺序根右左
            if(node->right)st.push(node->right);
            if(node->left)st.push(node->left);
        }
        return res;
    }
//3.二叉树的后序遍历
vector<int> postorderTraversal(TreeNode* root) {
        // write code here
        //迭代法实现
        vector<int>res;
        stack<TreeNode*>st;
        if(root!=nullptr){
            st.push(root);
        }
        while(!st.empty()){
            TreeNode *node=st.top();
            res.push_back(node->val);
            st.pop();
            if(node->left) st.push(node->left);
            if(node->right) st.push(node->right);
        }
        //反转顺序即可
        reverse(res.begin(), res.end());
        return res;
    }
//4.二叉树的层序遍历
vector<vector<int> > levelOrder(TreeNode* root) {
        vector<vector<int>>result;
        queue<TreeNode*>que;
        if(root!=nullptr)que.push(root);
        while(!que.empty()){
            int size=que.size();
            vector<int>vec;
            for(int i=0;i<size;i++){
                TreeNode*node=que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left)que.push(node->left);
                if(node->right)que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
//5.之字形打印二叉树
 vector<vector<int> > Print(TreeNode* pRoot) {
        //在层序遍历的基础上改编
        vector<vector<int>>result;
        queue<TreeNode*>que;
        if(pRoot!=nullptr)que.push(pRoot);
        while(!que.empty()){
            int size=que.size();
            vector<int>vec;
            for(int i=0;i<size;i++){
                TreeNode*node=que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left)que.push(node->left);
                if(node->right)que.push(node->right);
            }
            //按照result数组的元素个数判断是否需要翻转
            if(result.size()%2==0){
                result.push_back(vec);
            }
            else{
                reverse(vec.begin(),vec.end());
                result.push_back(vec);
            }
        }
        return result;
    }
//6.二叉树的镜像
TreeNode* Mirror(TreeNode* pRoot) {
        // write code here
        //相当于翻转二叉树
        if(pRoot==nullptr)return nullptr;
        swap(pRoot->left,pRoot->right);
        Mirror(pRoot->left);
        Mirror(pRoot->right);
        return pRoot;
    }
//7.合并二叉树
TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        // write code here
        TreeNode*root=new TreeNode(0);
        if(t1==nullptr)return t2;
        if(t2==nullptr)return t1;
        root->val=t1->val+t2->val;
        root->left=mergeTrees(t1->left, t2->left);
        root->right=mergeTrees(t1->right, t2->right);
        return root;
    }
//8.对称二叉树
    bool isSame(TreeNode* left,TreeNode* right){
        if(left==nullptr&&right==nullptr)return true;
        else if(left!=nullptr&&right==nullptr)return false;
        else if(left==nullptr&&right!=nullptr)return false;
        else if(left->val!=right->val)return false;
        return isSame(left->left, right->right)&&isSame(left->right, right->left);
       
    }
//判断一颗二叉树是否对称
    bool isSymmetrical(TreeNode* pRoot) {
        if(pRoot==nullptr)return true;
        return isSame(pRoot->left, pRoot->right);
    }
//9.判断是否是二叉搜索树
vector<int>vec;
    //中序遍历到数组中
    void traverse(TreeNode*root){
        if(root==nullptr)return;
        traverse(root->left);
        vec.push_back(root->val);
        traverse(root->right);
    }
    
    bool isValidBST(TreeNode* root) {
        // write code here
        vec.clear();
        traverse(root);
        for(int i=1;i<vec.size();i++){
            if(vec[i]<vec[i-1])return false;
        }
        return true;
    }
//10.判断是否是二叉平衡树
int getDepth(TreeNode *root){
        if(root==nullptr)return 0;
        int leftDepth=getDepth(root->left);
        if(leftDepth==-1)return -1;
        int rightDepth=getDepth(root->right);
        if(rightDepth==-1)return -1;
        return abs(leftDepth-rightDepth)>1?-1:1+max(leftDepth,rightDepth);
    }
    bool IsBalanced_Solution(TreeNode* pRoot) {
        return getDepth(pRoot)==-1?false:true;
    }
//11.和为某值的路径
 bool hasPathSum(TreeNode* root, int sum) {
        // write code here
       if(root==nullptr)return false;
       if(root->val==sum&&root->left==nullptr&&root->right==nullptr)return true;
        return hasPathSum(root->left, sum-root->val)||hasPathSum(root->right, sum-root->val);
    }

```



1. 字符串
2. 动态规划