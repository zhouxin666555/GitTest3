

项目内容

----

项目简介：

技术栈：

项目难点与解决方案：

项目的创新点和你的改进点：

项目结果：

#### 问答必知问题

-----



#### 1.select,poll,epoll的区别

- **调用函数不同**

-select,poll调用的是一个函数，epoll是它们的升级版，epoll调用的是一组函数：epoll_create;epoll_ctl;epoll_wait;

- **文件描述符数量限制不同**

-select有最大文件描述符限制，最大为1024，而poll和epoll无限制

*存储文件描述符集合采用的数据结构不同

-select采用线性表存储待监测的文件描述符

-poll采用链表

-epoll采用红黑树

- **查询就绪的文件描述符的方式不同**

-select,poll通过线性查找的方式判断文件描述符集合中是否有就绪的文件描述符

查找的时间复杂度为O(N);

-epoll通过回调机制，效率高，查找的时间复杂度为O(logN);epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。

- **将文件描述符从用户区传入内核区**

select和poll工作过程中存在内核/用户空间数据的频繁拷贝问题，在epoll中内核和用户区使用的是共享内存（基于mmap内存映射区实现），省去了不必要的内存拷贝。

- **应用程序索引就绪文件描述符**

- - select/poll只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历
  - epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可

- **工作模式**

- - select和poll都只能工作在相对低效的LT模式下
  - epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。 

- **应用场景**

- - 当所有的fd都是活跃连接，使用epoll，需要建立文件系统，红黑树和链表对于此来说，效率反而不高，不如select和poll
  - 当监测的fd数目较小，且各个fd都比较活跃，建议使用select或者poll，当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能

#### 2.epoll的两种工作模式LT和ET的区别

LT（水平模式）：LT（level triggered）是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核通知使用者哪些文件描述符已经就绪，之后就可以对这些已就绪的文件描述符进行 IO 操作了。如果我们不作任何操作，内核还是会继续通知使用者。【不处理事件不会善罢甘休】

ET（边沿模式）：ET（edge-triggered）是高速工作方式，只支持no-block socket。在这种模式下，当文件描述符从未就绪变为就绪时，内核会通过epoll通知使用者。然后它会假设使用者知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知（only once）。【好话不说二变】

综上所述：epoll 的边沿模式下 epoll_wait () 检测到文件描述符有新事件才会通知，如果不是新的事件就不通知，通知的次数比水平模式少，效率比水平模式要高。

**ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高**

#### 3.两种事件处理模式

- reator模式：l  主线程(I/O处理单元)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(逻辑单元 )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由同步I/O实现。

- proactor模式：l  主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由异步I/O实现。异步I/O并不成熟，实际使用中比较少。

#### 4.五种I/O模型

- 阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作
- 非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成eagain
- 信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO信号。然后处理IO事件。
- IO复用:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数
- 异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。

注意：阻塞I/O，非阻塞I/O，信号驱动I/O和I/O复用都是同步I/O。同步I/O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I/O操作，异步I/O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I/O操作。

